# REQ010: Message File 文件格式

本文档描述了Message File的文件格式规范，用于记录对话历史。Message File 可以记录多个 agent 的对话，并支持临时 agent 的定义和使用。

## 文件类型

支持两类文件：

1. 扩展名为 `.msg.md` 的文件：
   - 专用于消息记录
   - 整个文件都被视为消息记录

2. 扩展名为 `.md` 的普通Markdown文件：
   - 需要指定message记录存储的section/heading
   - 默认section名称为"Discussion"
   - 可以通过frontmatter指定section名称
   - 消息记录section必须是文件的最后一个section

## 文件格式详解

### 基本结构

Message File 采用基于 Markdown 的格式，使用百分比标记（percent notation）来组织消息单元（cell）。每个消息单元包含以下组成部分：

1. **标题行**：使用百分比标记和可选的标题
2. **元数据**：使用 Markdown 脚注语法定义
3. **内容**：消息或输出的实际内容

### 消息单元类型

1. **用户输入消息（Message Cell）**：
   - 使用 `# %%` 开头，其中 `#` 可以出现 1-5 次（如 `# %%`, `## %%`, `### %%` 等）
   - 多次出现的 `#` 有助于标准的 Markdown 阅读工具对齐 message file 的缩进逻辑
   - 可以是纯文本、Markdown 或代码

2. **输出消息（Output Cell）**：
   - 使用 `# %%%` 开头，其中 `#` 同样可以出现 1-5 次（如 `# %%%`, `## %%%` 等）
   - 表示对用户输入的响应
   - 可以是代理的回应、工具调用结果或代码执行输出

### 元数据定义

元数据使用 Markdown 脚注语法定义，格式为：

```markdown
[^id]: [type] key1="value1" key2="value2" history=value ...
```

其中：
- `id` 是消息的唯一标识符，可以是数字或文本
- `type` 指定消息类型，如 `[markdown]`、`[code]`、`[custom-agent]`、`[tool]` 等
- `history` 控制消息是否包含在 LLM 历史中：
  - `none` | `exclude` | `0` | `false`：不包含在历史中（即对 LLM 不可见）
  - `include` | `1` | `true`：完整包含（默认值）
  - `summary`：仅包含摘要
- 后续的键值对定义了消息的其他属性

### 用户输入消息格式

用户输入消息（Message Cell）的格式如下：

```markdown
# %% [可选标题][^id]

[^id]: [cell_type] key1="value1" key2="value2" history="include" ...

[消息内容]
```

其中：

- `# %%` 是消息单元的开始标记
- `[可选标题]` 是消息的标题，可以省略
- `[^id]` 是消息的唯一标识符，使用 Markdown 脚注语法
- `[cell_type]` 可以是 `[markdown]`、`[code]` 或 `[raw]`
- 键值对定义了消息的属性
- `[消息内容]` 是用户输入的实际内容

如果输入是代码，则系统将使用第一个代码块作为单元正文，语言类型由代码块指定。代码块之外的内容将被视为模型的推理过程。

### 输出消息格式

输出消息（Output Cell）的格式如下：

```markdown
# %%% [可选标题][^id]

[^id]: [output_type] key1="value1" key2="value2" history="exclude" ...

[输出内容]
```

其中：

- `# %%%` 是输出单元的开始标记，比用户输入多一个 `%`
- `[output_type]` 可以是 `[custom-agent]`、`[tool]` 或 `[lang]`（如 `[python]`）
- 其他元素与用户输入消息类似

#### 代理响应格式

```markdown
# %%% [可选标题][^id]

[^id]: [agent-name] time="2025-05-30T00:00:00+08:00" [reasoning=1]

[代理响应内容]
```

- `[agent-name]` 指定这是由哪个代理生成的响应，其中 agent-name 是 message file 中登记的代理名称
- `time` 记录响应的时间戳
- `reasoning=1` 可选属性，表示这是一个推理过程（当消息包含函数调用时）

#### 工具调用格式

```markdown
# %%% 工具调用[^id.nonce]

[^id.nonce]: [tool] name="tool_name"

... 工具调用消息（XML格式） ...
```

- `id` 是输出工具调用请求的 LLM 输出单元编号
- `nonce` 是随机序列，防止工具调用被重复构造
- `name` 指定工具名称，用于路由工具提供者

#### 工具调用结果格式

```markdown
# %%% 工具调用结果[^id.nonce.n]

[^id.nonce.n]: [tool] status="success" duration=0.5s

... 结果内容 ...
```

- `id.nonce` 与工具调用单元的标识符相对应
- `n` 是序号，用于区分多个结果
- `status` 表示调用状态（成功或失败）
- `duration` 记录调用持续时间

#### 代码执行输出格式

```markdown
# %%% [可选标题][^id.n]

[^id.n]: [lang] time="2025-05-30T00:00:00+08:00" status="success" duration=0.5s mime_type="text/plain"

stdout> 标准输出内容
stderr> 标准错误内容
```

- `[lang]` 指定脚本使用的语言（如 `[python]`）
- `id` 是关联的代码单元编号
- `n` 是代码执行的次数（与 Jupyter Notebook 兼容，如 In[1], Out[1]）
- `status` 表示执行状态（成功或失败）
- `duration` 记录执行持续时间
- `mime_type` 指定输出内容的MIME类型，默认为 `text/plain`
- 输出区域明确区分 stdout 和 stderr：
  - 标准输出行以 `stdout>` 前缀开头
  - 标准错误行以 `stderr>` 前缀开头
- 对于二进制输出，使用 `mime_type` 指定类型（如 `image/png`），内容使用 BASE64 编码
- 格式参考工具调用结果的格式，使用 `id.n` 表示代码执行的唯一标识
- 未来版本可能支持将输出记录到外部文件，通过 `output_file="path/to/file"` 属性指定

### 代理定义

代理定义分两种存储方式：

1. **系统预制代理**：记录在文件的 frontmatter 中
   - 可以定义多个预制代理
   - 每个代理有唯一的名称

2. **基于模型名称的临时代理**：记录在文件正文中
   - 可以动态添加临时代理
   - 临时代理可以在对话过程中创建和使用
   - 可以通过 `set default` 调整默认使用的代理
   - 可以通过 `list chat_file/agent` 列出当前对话记录中涉及的所有代理

代理的属性包括：
- models: 使用的模型名称列表
- context_window: 上下文窗口大小
- max_output_tokens: 最大输出标记数
- reasoning: 是否启用推理能力
- use_temperature: 是否启用温度（默认：True）
- temperature: 温度值
- system_prompt: 系统提示词（仅预制代理可定义）


## 文件集成说明

### 与其他组件的集成

1. **与普通Markdown文件的集成**：
   - 对于普通的Markdown文件，消息记录存储在名为"Discussion"的section中
   - 该section必须是文件的最后一节（之后是percent section）
   - 需要通过frontmatter声明激活消息记录功能

2. **与chat命令的集成**：
   - 使用chat命令时，需要提供`--force`参数来修改现有文件

3. **消息与函数调用的关联**：
   - 消息需要记录关联的FunctionCall列表
   - 每个Message可以关联多个FunctionCall
   - 函数调用结果作为输出单元保存

## 实现注意事项

1. 文件解析应基于行单位进行，根据`# %%`和`# %%%`将文件分为多个cell

2. 在实际处理中，cell同时也是heading/section

3. 对于代码输入，需要特殊处理第一个代码块

4. 对于工具调用，需要维护正确的ID关联和nonce生成

5. 文件格式设计兼顾了可读性和可解析性，使用标准Markdown语法
