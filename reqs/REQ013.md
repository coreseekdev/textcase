# REQ013: 测试用例关联与执行框架

## 1. 概述

本需求定义了一个完整的测试用例关联与执行框架，使用户能够在文档中关联和管理测试用例，并提供统一的执行机制。该框架允许用户直接从Markdown文件中记录、管理和执行测试用例，而无需关注项目实际使用的测试框架。

## 2. 目标

2.1. 建立标准化的Markdown文件测试用例记录格式

2.2. 提供命令行接口用于执行文档中引用的测试用例

2.3. 实现测试用例与实现代码之间的关联

2.4. 支持系统重构和演化过程中的测试用例管理

## 3. 命令行接口

3.1. 测试执行

```
tse run <测试标识符>
```

示例：
- `tse run REQ112/CASE-1` - 执行特定测试用例
- `tse run REQ112` - 执行模块中的所有测试用例
- `tse run /tests` - 执行项目中的所有测试用例

3.2. 测试发现

```
tse list <模块>/tests
```

## 4. 文档结构

4.1. 测试区域配置

测试区域可以在Markdown文档的前置元数据中定义：

```yaml
---
test_prefix: ["TST", "CASE", "TC"]
---
```

如果 head title 的前缀为 TST | CASE | TC , 则视为测试用例

4.2. 测试用例格式

测试用例通过特定前缀的标题识别，并遵循结构化格式：

```markdown
## CASE-1: 测试用例标题

测试意图和目的描述。

- 前置条件1
- 前置条件2

```python
# 测试实现代码
print("hello world")
assert 结果 == 预期值
```

- 验证点1
- 验证点2

- 相关实现: [@code:文件.函数名](src/模块.py#函数)
```

4.3. 测试用例组件

4.3.1. 通过标题识别测试用例

4.3.2. 内联代码块作为测试脚本

4.3.3. URI引用外部测试脚本

4.3.4. 在父级区域描述设置和清理程序

4.3.5. 前置条件和验证点作为列表项

4.3.6. 使用语法 `[@类型:标识符](路径)` 的资源引用

## 5. 资源引用系统

5.1. 引用类型

5.1.1. 代码引用: `[@code:标识符](文件路径#锚点)`

5.1.2. 文档引用: `[@doc:标识符](文档路径#章节)`

5.1.3. URL引用: `[@url:标识符](https://example.com/docs#section)`

5.1.4. Shell脚本引用: `[@shell:标识符](脚本路径.sh)`

5.2. 引用解析

系统在需要时解析引用以显示或执行关联的资源。

## 6. 测试用例示例

```markdown
## CASE-1: 用户认证验证

验证用户可以使用有效凭据进行认证。

- 系统中存在用户"testuser"，密码为"password123"
- 认证服务正在运行

```python
from auth import login
result = login.authenticate_user("testuser", "password123")
assert result.success == True
assert result.token is not None
```

- 认证成功，状态码为200
- 返回有效的JWT令牌

- 相关实现: [@code:auth.login](src/auth/login.py#authenticate_user)
```

## 7. 实现考虑

7.1. 测试解析器

系统必须根据结构而非特定关键词解析Markdown文档以识别和提取测试用例，从而支持国际化。

7.2. 测试运行器

测试运行器必须支持多种执行环境（Python、Shell）并透明地处理不同的测试框架。

7.3. 引用系统

引用系统必须解析指向代码、文档和其他资源的链接，为测试用例提供上下文。

7.4. 测试用例作为任务

测试用例可以被视为一种特殊的任务，具有以下特点：

7.4.1. 结构化表示

- 测试用例使用标题前缀（TST、CASE、TC）标识
- 包含前置条件、测试步骤和验证点等结构化元素
- 可以使用任务列表（`- [ ]`）表示验证点或测试步骤

7.4.2. 可跟踪性

- 测试用例可以通过资源引用系统关联到代码实现
- 可以通过链接关联到其他文档或资源
- 可以标记完成状态（`- [x]` 表示已完成，`- [ ]` 表示未完成）

7.4.3. 可执行性

- 测试用例可以包含可执行的代码块
- 可以通过 `tse run <测试标识符>` 命令执行
- 执行结果可以更新任务列表的状态

7.4.4. 与任务列表集成

测试用例可以利用任务列表功能：

```markdown
## TST-1: Markdown 解析器测试

**验证点:**
- [ ] parse_uri 正确解析 #meta 路径 [@test:TestParseUri.test_parse_meta_uri](tests/test_markdown_resolver.py)
- [ ] uri_to_query 返回正确的查询字符串 [@test:TestUriToQuery.test_meta_uri_to_query](tests/test_markdown_resolver.py)
- [ ] resolve 返回正确的文档项 [@test:TestResolve.test_resolve_meta](tests/test_markdown_resolver.py)
```

当测试执行通过后，可以更新为：

```markdown
## TST-1: Markdown 解析器测试

**验证点:**
- [x] parse_uri 正确解析 #meta 路径 [@test:TestParseUri.test_parse_meta_uri](tests/test_markdown_resolver.py)
- [x] uri_to_query 返回正确的查询字符串 [@test:TestUriToQuery.test_meta_uri_to_query](tests/test_markdown_resolver.py)
- [x] resolve 返回正确的文档项 [@test:TestResolve.test_resolve_meta](tests/test_markdown_resolver.py)
```

参考 pytest 的用法

```
# 运行特定文件中的特定测试函数
pytest tests/test_example.py::test_function_name

# 如果测试函数在类中
pytest tests/test_example.py::TestClass::test_method_name

# 运行特定文件中的所有测试类
pytest tests/test_example.py

# 只运行特定的测试类
pytest tests/test_example.py::TestClass

```

## 8. 示例格式

```markdown
## CASE-1: 示例描述测试代码

介绍测试意图

- 假设条件1
- 假设条件2

```python
print("hello world")
```

或

```shell
$ py-test test.py
```

- 检查点1（post check)
- 检查点2（post check)

- 相关资源: [@code:file.xxx_fn](src/module.py#function)
```

## 9. 资源引用方式

- 代码函数引用: `[@code:src/textcase/core/markdown_item.py#parse_markdown]`
- 文档章节引用: `[@doc:REQ006#文档格式]()`
- 网址引用: `[@url:https://example.com/docs#section-3]`
- 脚本引用: `[@shell:./scripts/test.sh]`

```

# 要点

将测试用例定义为一种特殊的任务类型，具有以下特点：

1. **结构化表示**：
   - 使用标题前缀（TST、CASE、TC）标识测试用例
   - 包含前置条件、测试步骤和验证点等结构化元素
   - 可以使用任务列表（`- [ ]`）表示验证点或测试步骤

2. **可跟踪性**：
   - 通过资源引用系统关联到代码实现
   - 可以链接到其他文档或资源
   - 可以标记完成状态（`- [x]` 已完成，`- [ ]` 未完成）

3. **可执行性**：
   - 包含可执行的代码块
   - 通过 `tse run <测试标识符>` 命令执行
   - 执行结果可以更新任务列表状态

4. **与任务列表集成**：
   - 验证点可以使用任务列表表示
   - 任务列表项可以链接到具体测试实现
   - 测试通过后可以自动更新任务列表状态

===============================================

## TST-6: 测试执行状态

NOTE: 应该考虑单独构造测试报告

**测试用例:** 用户认证流程 [@test:test_auth_flow](tests/auth/test_authentication.py)

**环境:** 
- 服务器: [@env:auth_server](http://localhost:8000)
- 数据库: [@env:db](postgresql://user:pass@localhost:5432/test)

**执行历史:**
- 2025-06-01 10:00:00 - 通过 (v1.2.3)
- 2025-06-01 09:30:00 - 失败 (v1.2.2) - 问题 #456
- 2025-06-01 09:00:00 - 通过 (v1.2.1)

**当前状态:**
- [x] 测试1
- [ ] 测试2 (阻塞: 问题 #789)
- [ ] 测试3

---------------------------------

## TST-{id}: {测试标题}

**描述:** {简要描述测试目的}

**前置条件:**
- 条件1
- 条件2

**测试步骤:**
1. 步骤1
2. 步骤2
3. 步骤3

**预期结果:**
- [ ] 结果1 [@test:{test_reference}]
- [ ] 结果2 [@test:{test_reference}]

**相关资源:**
- [@code:{实现文件}](path/to/file)
- [@doc:{相关文档}](path/to/doc)

------------------------------------------------

## TST-3: 解析器集成测试

**测试目标:** 验证解析器与文档的集成 [@test:TestIntegration](tests/integration/test_parser_integration.py)

**验证点:**
- [ ] 基本功能
  - [ ] 解析简单文档
  - [ ] 处理空文档
  - [ ] 处理只有 frontmatter 的文档

- [ ] 边界条件
  - [ ] 处理大文档
  - [ ] 处理特殊字符
  - [ ] 处理编码问题

- [ ] 错误处理
  - [ ] 处理不存在的文件
  - [ ] 处理格式错误的文档
  - [ ] 处理权限问题

--------------------------------------------------------

## TST-2: 参数化测试示例

**测试用例:** parse_uri 功能验证 [@test:test_parse_uri_combinations](tests/test_parser.py#test_parse_uri_combinations)

- [ ] 输入: `"#meta"` -> 预期: `[("rtype", "#meta")]`
- [ ] 输入: `"#frontmatter"` -> 预期: `[("rtype", "#meta")]`
- [ ] 输入: `None` -> 预期: `[("rtype", "#file")]`
- [ ] 输入: `"invalid#path"` -> 预期: 抛出异常

-------------------------------------------------------

## TST-1: Markdown 解析器功能测试

**测试组: 核心解析功能** [@test:TestParseUri](tests/test_markdown_resolver.py#TestParseUri)

- [ ] [xxx_fn](::xxx_fn) parse_uri 正确解析 #meta 路径
- [ ] [xxx_fn] parse_uri 正确解析 #frontmatter 路径
- [ ] [xxx_fn] parse_uri 正确处理 None 输入

**测试组: 查询功能** [@test:TestUriToQuery](tests/test_markdown_resolver.py#TestUriToQuery)
- [ ] [xxx_fn] uri_to_query 返回包含 frontmatter 的查询
- [ ] [xxx_fn] uri_to_query 处理不存在的资源类型

**测试组: 解析功能** [@test:TestResolve](tests/test_markdown_resolver.py#TestResolve)
- [ ] [xxx_fn] resolve 正确返回元数据项
- [ ] [xxx_fn] resolve 处理不存在的资源路径