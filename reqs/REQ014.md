# REQ014: 通用文档解析与资源定位系统

## 1. 概述

当前项目主要设计工作在编程领域，将文件视为一组资源的容器。本需求定义了一个通用的文档解析与资源定位系统，用于在各类文档中识别、引用和操作资源。系统将借助 tree-sitter 解析器将文本文件解析为结构化/半结构化(主要是 markdown)的文本，并提供统一的资源引用机制。

## 2. 目标

2.1. 建立通用的文档资源模型，支持多种文档类型

2.2. 提供统一的资源引用语法和解析机制

2.3. 实现资源定位、提取和操作的功能接口

2.4. 支持跨文档资源链接和追踪

## 3. 资源模型

3.1. 资源类型

3.1.1. 代码资源：函数、类、方法、变量等程序元素

3.1.2. 文档资源：章节、段落、列表、表格等文档元素

3.1.3. 外部资源：URL、文件路径、Shell命令等

3.1.4. 测试资源：测试用例、测试脚本、测试数据等

3.2. 资源属性

3.2.1. 唯一标识符：用于定位和引用资源

3.2.2. 类型信息：指示资源的类别和性质

3.2.3. 内容：资源的实际内容或值

3.2.4. 元数据：与资源相关的附加信息

## 4. 资源引用语法

4.1. 基本语法

使用统一的引用语法 `[@类型:标识符](路径#锚点)` 引用各类资源：

```markdown
[@code:函数名](src/模块.py#函数名)  # 引用代码函数
[@doc:需求ID](REQ006.md#章节名)    # 引用文档章节
[@url:标题](https://example.com)   # 引用网址
[@shell:脚本名](./scripts/test.sh) # 引用Shell脚本
```

4.2. 引用解析

系统将解析文档中的引用，识别引用的资源类型、标识符和路径，并根据需要提取或操作相应资源。

## 5. 文档解析机制

5.1. 解析技术

5.1.1. 使用 tree-sitter 进行代码文件的精确解析

5.2. 解析结果

5.2.1. 文档结构树：表示文档的层次结构

5.2.2. 资源索引：记录文档中包含的各类资源

5.2.3. 引用关系图：表示资源之间的引用关系

## 6. 资源操作接口

6.1. 资源查询

```
tse find <资源类型>:<查询表达式>
```

示例：
- `tse find code:"parse_markdown"` - 查找名为 parse_markdown 的代码函数
- `tse find doc:"REQ013#测试用例格式"` - 查找 REQ013 中的测试用例格式章节

6.2. 资源定位

定位资源的具体位置，以便其他工具提取或编辑

```
tse locate <资源引用>
```

6.3. 资源链接

```
tse link <源资源> <目标资源> [-l "链接文本"]
```

## 7. 与现有功能集成

7.1. 与测试用例系统集成

测试用例可以通过资源引用语法关联到代码实现和其他资源。

7.2. 与任务列表集成

任务列表项可以包含资源引用，指向相关实现或文档。

7.3. 与文档生成系统集成

在生成文档时，可以解析和展开资源引用，提供更丰富的内容。

## 8. 实现考虑

8.1. 解析性能

对于大型文档和代码库，需要考虑解析性能和增量更新机制。

8.2. 资源缓存

实现资源缓存机制，避免重复解析和提取。

8.3. 引用完整性

提供引用完整性检查，识别和报告失效的资源引用。

## 9. 示例应用场景

9.1. 需求追踪

在需求文档中引用相关代码实现和测试用例，实现需求-代码-测试的双向追踪。

9.2. 代码文档化

在代码注释中引用需求文档和设计文档，增强代码的可理解性。

9.3. 知识库构建

通过资源引用建立项目知识图谱，支持知识发现和导航。

## 10. 未来扩展

10.1. 资源版本控制

支持资源的版本管理，追踪资源随时间的变化。

10.2. 资源权限控制

实现基于角色的资源访问控制机制。

10.3. 资源协作编辑

支持多用户同时编辑和引用资源。


# NOTE

接下来，我们需要定 通用的 URIResolver 抽象，

1. 从 URI 到 tree-sitter query 
2. 解析 query 获取结果后，对结果进行包装，后处理。

对于下面的常见语言，（可能）需要独立的 Resolver 

- Markdown
- Python
- C
- C++
- Rust
- Go
- Javascript 
-  Typescript
-  Rust 
-  CMake

我们当前先