# REQ012: Message File 接口

本文档描述了操作和访问 Message File 的接口设计。

## 接口设计原则

1. message | request ，应考虑包装为一个对象，以便后续支持多模态
2. output | response ，应考虑包装为一个对象，以便后续支持多模态
3. 所有接口使用抽象协议（Protocol）定义，不包含具体实现细节
4. 使用 Builder 模式创建对象，避免直接使用构造函数

## 核心协议

- `MessageOutput`: 表示消息输出的协议
  - 属性: content, mime_type, nonce
  - 方法: to_dict

- `CodeExecutionOutput`: 继承自 MessageOutput，表示代码执行输出
  - 额外属性: stdout_content, stderr_content, status, duration, lang
  - 额外方法: to_dict

- `MessageItem`: 表示消息项的基础协议
  - 属性: name, timeout, outputs, type, history, heading_level
  - 方法: add_output, to_dict

- `Message`: 继承自 MessageItem，表示消息
  - 额外属性: content, mime_type, agent_name
  - 额外方法: add_function_call

- `FunctionCall`: 继承自 MessageItem，表示函数调用
  - 额外属性: function_name, args

- `AgentProtocol`: 表示代理的协议
  - 属性: name, models, context_window, max_output_tokens, reasoning, use_temperature, temperature, system_prompt
  - 方法: to_dict, from_dict

- `AgentFactoryProtocol`: 表示代理工厂的协议
  - 方法: get_agent, register_agent, list_agents

## 构建器

- `MessageOutputBuilder`: 用于构建 MessageOutput 实例
  - 方法: with_content, with_mime_type, with_nonce, with_binary_content, build

- `CodeExecutionOutputBuilder`: 用于构建 CodeExecutionOutput 实例
  - 方法: with_stdout, with_stderr, with_status, with_duration, with_lang, build

- `MessageBuilder`: 用于构建 Message 实例
  - 方法: with_name, with_timeout, with_output, with_content, with_mime_type, with_agent_name, with_function_call, with_history, with_heading_level, with_binary_content, build

- `FunctionCallBuilder`: 用于构建 FunctionCall 实例
  - 方法: with_name, with_timeout, with_output, with_function_name, with_args, with_history, with_heading_level, build

## 消息文件接口列表

- `get_path()`: 获取消息文件的路径

- `get_items()`: 获取文件中所有的消息项（Message和FunctionCall）

- `get_agents()`: 获取文件中定义的所有代理

- `add_agent(agent_name, override_settings=None)`: 添加代理
  - override_settings 用于覆盖代理的默认设置（如 context_window, temperature 等）
  - 不能修改 models | system_prompt 等

- `add_agent_with_definition(agent_name, definition)`: 使用自定义定义添加代理

- `set_default_agent(agent_name)`: 设置默认代理

- `default_agent()`: 获取默认代理
  - 可能返回 None，此时不能执行推理
  - 当没有默认代理时，调用 add_message | add_function_call 应报错

- `add_message(content, name=None, mime_type="text/plain", agent_name=None, timeout=None)`: 添加消息
  - 返回一个符合 Message 协议的对象
  - 如果 name 为空，则自动生成(顺序编号)
  - 如果 agent_name 为空，则使用默认代理
  - 不直接使用构造函数，而是通过 MessageBuilder 创建

- `add_function_call(message_name, function_name, args=None, name=None, timeout=None)`: 添加函数调用
  - 返回一个符合 FunctionCall 协议的对象
  - message_name 是要添加函数调用的消息名称
  - function_name 可以是函数名称，也可以是代理名称
  - 不直接使用构造函数，而是通过 FunctionCallBuilder 创建

- `get_item(index_or_name)`: 通过索引或名称获取消息项
  - 返回一个符合 MessageItem 协议的对象（Message或FunctionCall）

- `save()`: 保存消息文件

- `load()`: 从磁盘加载消息文件

## 暂时不考虑支持的接口

- `add_output_placeholder(message_name, placeholder_name, agent_name=None, nonce=None)`
  - 用于异步调用，placeholder_name 为存储实际推理结果的文件名
  - nonce 用于标识输出的唯一性
  - agent_name 的位置也可能是 function_name 

- `add_tool_with_definition(tool_name, definition)`
  - definition 是一个 message 的数组，用于交互的使用 python 定义工具
