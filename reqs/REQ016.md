# REQ016: 统一资源标识符(URI)在结构化文档中的实现规范

## 概述

本规范定义了在结构化文档（如Markdown）中实现统一资源标识符(URI)的方法，使系统能够精确定位和引用文档中的特定内容元素。本规范与 REQ017 中定义的项目与模块体系紧密相关。

## 核心概念

1. **URI结构分层**：遵循RFC 3986规范，URI分为两个主要部分：
   
   - **资源路径部分**：用于定位模块内的特定文档项和文档内的路径
     - 格式：`{prefix}{sep}{id}/{heading_path}`
     - 示例：`REQ001/heading1/subheading`或`REQ001/heading1`
     - 注意：前缀数字的前导零是可选的，如`REQ1`和`REQ001`是等价的
     - ID可以是数字或字符串，只需在模块内保证唯一性
   
   - **片段标识部分**：使用`#`符号后跟片段标识符，用于指定资源类型
     - 示例：`REQ001/#meta`（引用元数据）、`REQ001/heading1/#item`（引用特定标题下的内容）
     - 资源类型包括：`#meta`（元数据）、`#item`（内容项）、`#link`（链接）、`#code`（代码块）等
     - 片段标识 不限于资源类型，还可以是某种表达式，取决于文档的类型（如文档为源代码）

2. **路径解析策略**：

   - **直接定位**：通过模块前缀和ID直接定位文档项
     - 格式：`{prefix}{id}`，分隔符可选
     - 示例：`REQ001`或`REQ1`直接定位到文档
     - 由于模块前缀在项目中唯一，无需额外定位辅助
   
   - **复合路径定位**：先定位文档项，再定位内部标题路径
     - 格式：`{prefix}{id}/{heading_path}`
     - 示例：`REQ001/背景/LLM支持`定位到标题路径
     - 如果只给出前缀，含义是定位到模块本身
   
   - **源代码模块定位**：源代码可以作为特殊模块注册到系统
     - 格式：`{source_module}/{path/to/file}`
     - 示例：`SRC/src/textcase/core/vfs.py`定位到源代码文件
     - 允许引用第三方组件的源代码，如`EXTERNAL/lib/dependency.py`
     - 源代码模块在配置中标记为特殊类型，以区别于普通文档模块

3. **复合路径与资源类型**：

   - **标题路径定位**：使用标题层次结构定位
     - 格式：`{prefix}{id}/{heading1}/{heading2}/...`
     - 示例：`REQ001/背景/LLM支持`定位到“背景”下的“LLM支持”子标题
     - 支持部分匹配，如`REQ001/LLM`可能匹配到包含“LLM”的标题
     - 当仅有资源路径部分、无片段标识部分时，允许模糊匹配，如：
       - `head/TST1` 可以匹配文档中的 `TST1: xxxx`、`[TST-01] xxxx`、`` `TST-001` xxxx ``、`TST-01` 等形式
   
   - **源代码路径定位**：使用文件路径和程序元素定位
     - 格式：`{path/to/file.py}/{element_path}`
     - 示例：`src/textcase/core/vfs.py/get_default_vfs`定位到指定文件中的函数
     - 元素路径可以是函数、类、方法或其他程序元素
     - 示例：`src/textcase/core/vfs.py/VFS/get_file`定位到类中的方法
   
   - **资源类型指定**：使用`#`后跟资源类型
     - `#meta`：引用文档的元数据（frontmatter）
     - `#item`：引用标题下的内容区域
     - `#link`：引用文档中的链接
     - `#code`：引用代码块
     - 对于源代码文件，片段标识可以是行号或其他表达式
     - 示例：`src/textcase/core/vfs.py#L10-L20`引用指定行范围


## 文档的编辑

1. 支持文档进行编辑，但是不直接修改文件的 bytes 表示，而是返回一组编辑指令（replace 类似）